/**
 * Synchronizacja cen do Supabase
 * Skrypt odczytuje dane z arkuszy Produkty, Opcje, Wartości, Listy
 * i wysyła je do bazy danych.
 *
 * FIX:
 * - Gdy model jest pusty w Opcje/Wartości/Listy, dane są stosowane do wszystkich modeli produktu.
 * - Brak dublowania opcji/wartości przy fan-oucie.
 */

const CONFIG = {
  SUPABASE_URL: "https://xuwapsacaymdemmvblak.supabase.co",
  ANON_KEY:
    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inh1d2Fwc2FjYXltZGVtbXZibGFrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY4MTg3ODYsImV4cCI6MjA3MjM5NDc4Nn0.qMH2oXCcutbLFdg-IBgJkyfjhq2mQftEUBYfr8e8s2Y",
  SHEET_USTAWIENIA: "Ustawienia",
  PASSWORD_CELL: "B1",
  SHEET_PRODUKTY: "Produkty",
  SHEET_OPCJE: "Opcje",
  SHEET_WARTOSCI: "Wartości",
  SHEET_LISTY: "Listy",
  DATA_START_ROW_PRODUKTY: 6,
  DATA_START_ROW_OPCJE: 3,
  DATA_START_ROW_WARTOSCI: 2,
  DATA_START_ROW_LISTY: 2,
};

interface NumericRule {
  min_value: number;
  max_value: number;
  step_value: number;
  price_per_step_cents: number;
  base_included_value: number;
}

interface OptionValue {
  name: string;
  price_delta_cents: number;
  position: number;
}

interface OptionGroup {
  name: string;
  input_type: "select" | "numeric_step";
  required: boolean;
  position: number;
  values?: OptionValue[];
  parent?: { group_name: string; value_name: string };
  numeric_rule?: NumericRule;
}

interface Variant {
  price_key: string;
  brand: string;
  product: string;
  model: string | null;
  base_price_cents: number;
  currency: string;
  position: number;
  related_products?: string[];
  groups: OptionGroup[];
}

interface WartosciIndex {
  exact: Map<string, NumericRule>;
  fallbackByProduct: Map<string, NumericRule>;
}

interface ListyIndex {
  exact: Map<string, OptionValue[]>;
  fallbackByProduct: Map<string, OptionValue[]>;
}

interface ReadOpcjeStats {
  rowsProcessed: number;
  rowsSkippedNoVariant: number;
  rowsFanout: number;
  parentGroupsCreated: number;
  childGroupsCreated: number;
}

function parsePriceToCents(priceStr: string): number {
  if (!priceStr || priceStr.trim() === "") return 0;
  const cleaned = priceStr
    .replace(/zł/gi, "")
    .replace(/PLN/gi, "")
    .replace(/\s/g, "")
    .replace(",", ".")
    .trim();
  const value = parseFloat(cleaned);
  return isNaN(value) ? 0 : Math.round(value * 100);
}

function parsePolishDecimal(str: string): number {
  if (!str || str.trim() === "") return 0;
  const value = parseFloat(str.replace(",", ".").trim());
  return isNaN(value) ? 0 : value;
}

function isSuspiciousValue(value: string): boolean {
  const t = value.trim();
  if (!t) return true;
  if (/^\d+$/.test(t) || /^\d+[.,]\d+$/.test(t)) return true;
  const errors = ["#REF!", "#VALUE!", "#NAME?", "#DIV/0!", "#N/A", "#NULL!", "#NUM!"];
  for (const e of errors) {
    if (t.includes(e)) return true;
  }
  if (/^[£$€¥]\d/.test(t)) return true;
  if (t.length === 1 && !/[a-zA-ZąćęłńóśźżĄĆĘŁŃÓŚŹŻ]/.test(t)) return true;
  return false;
}

function normalizeModel(modelRaw: string): string | null {
  const m = modelRaw.trim();
  return m === "" ? null : m;
}

function variantKey(product: string, model: string | null): string {
  return model ? `${product}|||${model}` : `${product}|||`;
}

function cellStr(row: (string | number | boolean)[], index: number): string {
  const val = row[index];
  return val === null || val === undefined ? "" : String(val).trim();
}

function makeExactOptionKey(product: string, model: string | null, opcja: string): string {
  return `${product}|||${model ?? ""}|||${opcja}`;
}

function makeFallbackOptionKey(product: string, opcja: string): string {
  return `${product}|||${opcja}`;
}

function resolveNumericRule(
  index: WartosciIndex,
  product: string,
  model: string | null,
  opcja: string
): NumericRule | undefined {
  const exact = index.exact.get(makeExactOptionKey(product, model, opcja));
  if (exact) return exact;
  return index.fallbackByProduct.get(makeFallbackOptionKey(product, opcja));
}

function resolveListValues(
  index: ListyIndex,
  product: string,
  model: string | null,
  opcja: string
): OptionValue[] | undefined {
  const exact = index.exact.get(makeExactOptionKey(product, model, opcja));
  if (exact && exact.length > 0) return exact;
  const fallback = index.fallbackByProduct.get(makeFallbackOptionKey(product, opcja));
  return fallback && fallback.length > 0 ? fallback : undefined;
}

function getTargetVariantKeys(
  variants: Map<string, Variant>,
  product: string,
  model: string | null
): string[] {
  if (model !== null) {
    const key = variantKey(product, model);
    return variants.has(key) ? [key] : [];
  }

  // Model pusty => wszystkie modele danego produktu
  const keys: string[] = [];
  for (const [key, variant] of variants.entries()) {
    if (variant.product === product) keys.push(key);
  }
  return keys;
}

function readProdukty(workbook: ExcelScript.Workbook): Map<string, Variant> {
  const sheet = workbook.getWorksheet(CONFIG.SHEET_PRODUKTY);
  if (!sheet) return new Map();
  const usedRange = sheet.getUsedRange();
  if (!usedRange) return new Map();
  const data = usedRange.getValues();
  const variants = new Map<string, Variant>();

  let position = 0;

  for (let i = CONFIG.DATA_START_ROW_PRODUKTY; i < data.length; i++) {
    const row = data[i];
    const brand = cellStr(row, 0);
    const product = cellStr(row, 1);
    const model = normalizeModel(cellStr(row, 2));
    const priceStr = cellStr(row, 4);
    const priceKey = cellStr(row, 6);
    const p1 = cellStr(row, 9);
    const p2 = cellStr(row, 10);
    const p3 = cellStr(row, 11);
    const p4 = cellStr(row, 12);

    if (!brand || !product || !priceKey) continue;
    if (priceKey.toLowerCase() === "url" || product.toLowerCase() === "produkt") continue;
    if (!priceKey.includes("/")) continue;

    const relatedProducts = [p1, p2, p3, p4].filter((p) => p && p.trim() !== "");

    variants.set(variantKey(product, model), {
      price_key: priceKey,
      brand,
      product,
      model,
      base_price_cents: parsePriceToCents(priceStr),
      currency: "PLN",
      position: position++,
      related_products: relatedProducts.length > 0 ? relatedProducts : undefined,
      groups: [],
    });
  }

  return variants;
}

function readWartosci(workbook: ExcelScript.Workbook): WartosciIndex {
  const sheet = workbook.getWorksheet(CONFIG.SHEET_WARTOSCI);
  const result: WartosciIndex = { exact: new Map(), fallbackByProduct: new Map() };
  if (!sheet) return result;

  const usedRange = sheet.getUsedRange();
  if (!usedRange) return result;
  const data = usedRange.getValues();

  for (let i = CONFIG.DATA_START_ROW_WARTOSCI; i < data.length; i++) {
    const row = data[i];
    const product = cellStr(row, 0);
    const model = normalizeModel(cellStr(row, 1));
    const opcja = cellStr(row, 2);

    if (!product || !opcja) continue;
    if (product.toLowerCase() === "produkt" || opcja.toLowerCase() === "opcja") continue;
    if (isSuspiciousValue(opcja)) continue;

    const minVal = parsePolishDecimal(cellStr(row, 3));
    const maxVal = parsePolishDecimal(cellStr(row, 4));
    const stepVal = parsePolishDecimal(cellStr(row, 5));

    const rule: NumericRule = {
      min_value: minVal,
      max_value: maxVal,
      step_value: stepVal > 0 ? stepVal : 1,
      price_per_step_cents: parsePriceToCents(cellStr(row, 6)),
      base_included_value: minVal,
    };

    if (model === null) {
      result.fallbackByProduct.set(makeFallbackOptionKey(product, opcja), rule);
    } else {
      result.exact.set(makeExactOptionKey(product, model, opcja), rule);
    }
  }

  return result;
}

function readListy(workbook: ExcelScript.Workbook): ListyIndex {
  const sheet = workbook.getWorksheet(CONFIG.SHEET_LISTY);
  const result: ListyIndex = { exact: new Map(), fallbackByProduct: new Map() };
  if (!sheet) return result;

  const usedRange = sheet.getUsedRange();
  if (!usedRange) return result;
  const data = usedRange.getValues();

  for (let i = CONFIG.DATA_START_ROW_LISTY; i < data.length; i++) {
    const row = data[i];
    const product = cellStr(row, 0);
    const model = normalizeModel(cellStr(row, 1));
    const opcja = cellStr(row, 2);
    const valueName = cellStr(row, 3);

    if (!product || !opcja || !valueName) continue;
    if (product.toLowerCase() === "produkt" || opcja.toLowerCase() === "opcja") continue;
    if (isSuspiciousValue(opcja)) continue;

    const targetMap = model === null ? result.fallbackByProduct : result.exact;
    const key =
      model === null
        ? makeFallbackOptionKey(product, opcja)
        : makeExactOptionKey(product, model, opcja);

    if (!targetMap.has(key)) targetMap.set(key, []);
    const values = targetMap.get(key)!;
    values.push({
      name: valueName,
      price_delta_cents: parsePriceToCents(cellStr(row, 4)),
      position: values.length,
    });
  }

  return result;
}

function readOpcje(
  workbook: ExcelScript.Workbook,
  variants: Map<string, Variant>,
  wartosciIndex: WartosciIndex,
  listyIndex: ListyIndex
): ReadOpcjeStats {
  const sheet = workbook.getWorksheet(CONFIG.SHEET_OPCJE);
  const stats: ReadOpcjeStats = {
    rowsProcessed: 0,
    rowsSkippedNoVariant: 0,
    rowsFanout: 0,
    parentGroupsCreated: 0,
    childGroupsCreated: 0,
  };

  if (!sheet) return stats;
  const usedRange = sheet.getUsedRange();
  if (!usedRange) return stats;
  const data = usedRange.getValues();

  const variantGroups = new Map<string, OptionGroup[]>();
  const parentGroupsMap = new Map<string, Map<string, OptionGroup>>();

  for (let i = CONFIG.DATA_START_ROW_OPCJE; i < data.length; i++) {
    const row = data[i];
    const product = cellStr(row, 0);
    const rowModel = normalizeModel(cellStr(row, 1));
    const opcjaName = cellStr(row, 2);
    const valueNameRaw = cellStr(row, 3);
    const valueName = valueNameRaw || opcjaName;
    const priceStr = cellStr(row, 4);
    const podOpcjaWartosci = cellStr(row, 5);
    const podOpcjaListy = cellStr(row, 6);

    if (!product || !opcjaName) continue;
    if (product.toLowerCase() === "produkt" || opcjaName.toLowerCase() === "opcja") continue;

    stats.rowsProcessed++;

    const targetKeys = getTargetVariantKeys(variants, product, rowModel);
    if (targetKeys.length === 0) {
      stats.rowsSkippedNoVariant++;
      continue;
    }
    if (rowModel === null && targetKeys.length > 1) stats.rowsFanout += targetKeys.length;

    for (const vKey of targetKeys) {
      const variant = variants.get(vKey);
      if (!variant) continue;

      if (!variantGroups.has(vKey)) variantGroups.set(vKey, []);
      if (!parentGroupsMap.has(vKey)) parentGroupsMap.set(vKey, new Map());

      const allGroups = variantGroups.get(vKey)!;
      const parentGroups = parentGroupsMap.get(vKey)!;

      if (!parentGroups.has(opcjaName)) {
        const newGroup: OptionGroup = {
          name: opcjaName,
          input_type: "select",
          required: false,
          position: parentGroups.size,
          values: [],
        };
        parentGroups.set(opcjaName, newGroup);
        allGroups.push(newGroup);
        stats.parentGroupsCreated++;
      }
      const parentGroup = parentGroups.get(opcjaName)!;
      if (!parentGroup.values) parentGroup.values = [];

      const parentValuePrice = parsePriceToCents(priceStr);
      const parentValueExists = parentGroup.values.some(
        (v) => v.name === valueName && v.price_delta_cents === parentValuePrice
      );
      if (!parentValueExists) {
        parentGroup.values.push({
          name: valueName,
          price_delta_cents: parentValuePrice,
          position: parentGroup.values.length,
        });
      }

      if (podOpcjaWartosci && !isSuspiciousValue(podOpcjaWartosci)) {
        const rule = resolveNumericRule(
          wartosciIndex,
          product,
          variant.model,
          podOpcjaWartosci
        );
        if (rule) {
          const exists = allGroups.some(
            (g) =>
              g.name === podOpcjaWartosci &&
              g.input_type === "numeric_step" &&
              g.parent?.group_name === opcjaName &&
              g.parent?.value_name === valueName
          );

          if (!exists) {
            allGroups.push({
              name: podOpcjaWartosci,
              input_type: "numeric_step",
              required: false,
              position: allGroups.length,
              parent: { group_name: opcjaName, value_name: valueName },
              numeric_rule: rule,
            });
            stats.childGroupsCreated++;
          }
        }
      }

      if (podOpcjaListy && !isSuspiciousValue(podOpcjaListy)) {
        const childValues = resolveListValues(
          listyIndex,
          product,
          variant.model,
          podOpcjaListy
        );

        if (childValues && childValues.length > 0) {
          const exists = allGroups.some(
            (g) =>
              g.name === podOpcjaListy &&
              g.input_type === "select" &&
              g.parent?.group_name === opcjaName &&
              g.parent?.value_name === valueName
          );

          if (!exists) {
            allGroups.push({
              name: podOpcjaListy,
              input_type: "select",
              required: false,
              position: allGroups.length,
              parent: { group_name: opcjaName, value_name: valueName },
              values: childValues,
            });
            stats.childGroupsCreated++;
          }
        }
      }
    }
  }

  for (const [vKey, groups] of variantGroups.entries()) {
    const variant = variants.get(vKey);
    if (variant) variant.groups = groups;
  }

  return stats;
}

async function main(workbook: ExcelScript.Workbook): Promise<void> {
  const startedAt = Date.now();
  console.log("Rozpoczynam synchronizację...");

  try {
    const settingsSheet = workbook.getWorksheet(CONFIG.SHEET_USTAWIENIA);
    if (!settingsSheet) {
      console.log('BŁĄD: Brak arkusza "Ustawienia" z hasłem w komórce B1');
      return;
    }

    const password = String(settingsSheet.getRange(CONFIG.PASSWORD_CELL).getValue() || "")
      .trim()
      .replace(/[^\x20-\x7E]/g, "");

    if (!password || password.length < 8) {
      console.log('BŁĄD: Hasło musi mieć min. 8 znaków (komórka B1 w arkuszu Ustawienia)');
      return;
    }

    console.log("Czytam arkusz Produkty...");
    const variants = readProdukty(workbook);
    if (variants.size === 0) {
      console.log("BŁĄD: Nie znaleziono produktów");
      return;
    }
    console.log(`Produkty (warianty): ${variants.size}`);

    console.log("Czytam arkusz Wartości...");
    const wartosciIndex = readWartosci(workbook);

    console.log("Czytam arkusz Listy...");
    const listyIndex = readListy(workbook);

    console.log("Czytam arkusz Opcje i mapuję grupy...");
    const opcjeStats = readOpcje(workbook, variants, wartosciIndex, listyIndex);

    console.log(
      `Opcje: przetworzono ${opcjeStats.rowsProcessed} wierszy, fan-out: ${opcjeStats.rowsFanout}, ` +
        `pominięte (brak wariantu): ${opcjeStats.rowsSkippedNoVariant}, ` +
        `utworzone grupy nadrzędne: ${opcjeStats.parentGroupsCreated}, podrzędne: ${opcjeStats.childGroupsCreated}`
    );

    const variantsArray = Array.from(variants.values());
    const invalid = variantsArray.find(
      (v) =>
        !v.price_key ||
        !v.brand ||
        !v.product ||
        typeof v.base_price_cents !== "number" ||
        typeof v.position !== "number" ||
        !Array.isArray(v.groups)
    );
    if (invalid) {
      console.log(
        `BŁĄD: Niepoprawny payload dla wariantu: ${invalid.product} / ${invalid.model || "-"}`
      );
      return;
    }

    const payload = { mode: "replace", variants: variantsArray };
    console.log(`Wysyłam ${variantsArray.length} produktów do pricing-ingest...`);

    const response = await fetch(CONFIG.SUPABASE_URL + "/functions/v1/pricing-ingest", {
      method: "POST",
      headers: {
        Authorization: "Bearer " + CONFIG.ANON_KEY,
        "X-Excel-Token": password,
        "Content-Type": "application/json; charset=utf-8",
      },
      body: JSON.stringify(payload),
    });

    const responseText = await response.text();
    if (!response.ok) {
      console.log(`BŁĄD HTTP ${response.status}: ${responseText}`);
      return;
    }

    const result = JSON.parse(responseText) as {
      ok?: boolean;
      supabase?: { counts?: { variants?: number }; deleted_products?: number };
    };

    const elapsedSec = Math.round((Date.now() - startedAt) / 1000);
    console.log("=== SYNCHRONIZACJA ZAKOŃCZONA ===");
    console.log(`Status: ${result.ok ? "SUKCES ✓" : "BŁĄD"}`);
    if (result.supabase?.counts) {
      console.log(`Zaktualizowano: ${result.supabase.counts.variants} produktów`);
    }
    if (result.supabase?.deleted_products && result.supabase.deleted_products > 0) {
      console.log(`Usunięto: ${result.supabase.deleted_products} produktów (brak URL)`);
    }
    console.log(`Czas wykonania: ${elapsedSec}s`);
    console.log("Ceny w Sanity zostaną zaktualizowane w tle.");
  } catch (error) {
    console.log(
      `BŁĄD: ${error instanceof Error ? error.message : JSON.stringify(error)}`
    );
  }
}
